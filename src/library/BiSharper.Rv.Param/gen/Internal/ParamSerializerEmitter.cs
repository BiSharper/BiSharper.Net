using System;
using System.IO;
using System.Linq;
using BiSharper.Rv.Param.Generator.Internal.MetaData;
using BiSharper.Rv.Param.Serialization;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace BiSharper.Rv.Param.Generator.Internal;

internal static class ParamSerializerEmitter
{
    public static void GenerateSourceOutput(SourceProductionContext context, ((TypeDeclarationSyntax syntax, Compilation compilation) source, string? logPath) arguments) =>
        GenerateSourceOutput(arguments.source.syntax, arguments.source.compilation, arguments.logPath, context);

    public static void GenerateSourceOutput(
        TypeDeclarationSyntax syntax,
        Compilation compilation,
        string? logPath,
        SourceProductionContext context
    )
    {
        var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);

        if (ModelExtensions.GetDeclaredSymbol(semanticModel, syntax, context.CancellationToken) is not INamedTypeSymbol typeSymbol) return;
        if (!LooksValid(syntax, typeSymbol, out var diagnostic))
        {
            if (diagnostic != null) context.ReportDiagnostic(diagnostic);
            return;
        }

        var reference = new ReferenceSymbols(compilation);
        if (!ShouldGenerateSerializableType(typeSymbol, reference, syntax, out diagnostic, out var meta))
        {
            if (diagnostic != null) context.ReportDiagnostic(diagnostic);
            return;
        }

        var fullType = meta.Symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");
        var writer = new StringWriter();
        writer.WriteLine
        (
            """
            // <auto-generated/>
            #nullable enable
            #pragma warning disable CS0162 // Unreachable code
            #pragma warning disable CS0164 // This label has not been referenced
            #pragma warning disable CS0219 // Variable assigned but never used
            #pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.
            #pragma warning disable CS8601 // Possible null reference assignment
            #pragma warning disable CS8604 // Possible null reference argument for parameter
            #pragma warning disable CS8631 // The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match constraint type.
            #pragma warning disable CA1050 // Declare types in namespaces.

            using System;
            using BiSharper.Rv.Param;
            """
        );
        var @namespace = meta.Symbol.ContainingNamespace;
        if(!@namespace.IsGlobalNamespace) writer.WriteLine($"namespace {@namespace};");

        meta.EmitSource(writer);

        context.AddSource($"{fullType}.ParamSerializer.g.cs", writer.ToString());
    }

    private static void EmitSource(this ParamSerializableType meta, TextWriter writer)
    {
        writer.WriteLine(
            //TODO: Readonly keyword
            $$"""
            public partial {{(meta.IsRecord, meta.IsValueType) switch
            {
                (true, true) => "record struct",
                (true, false) => "record",
                (false, true) => "struct",
                (false, false) => "class",
            }}} {{meta.TypeName}} : {{meta.Reference.ParamContextInterface}} {
            
                // ParamSerializable Members
                {{meta.EmitMembers()}}
            
                // ParamSerializable Construction
                {{meta.EmitConstruction()}}
            }
            """
        );
    }

    private static string EmitMembers(this ParamSerializableType meta) =>
    $$"""
      

      """;

    private static string EmitConstruction(this ParamSerializableType meta) =>
        $$"""
        public {{meta.TypeName}}({{meta.TypeName}} context) {
            
        }
        """;

    private static bool ShouldGenerateSerializableType(
        INamedTypeSymbol typeSymbol,
        ReferenceSymbols reference,
        TypeDeclarationSyntax syntax,
        out Diagnostic? diagnostic,
        out ParamSerializableType type
    ) => !(!(type = new ParamSerializableType(typeSymbol, reference)).ValidateForGeneration(syntax, out diagnostic) ||
           type.SerializationMode != ParamSerializationMode.SkipGeneration);

    private static bool LooksValid(BaseTypeDeclarationSyntax syntax, ISymbol symbol, out Diagnostic? diagnostic)
    {
        DiagnosticDescriptor? error = null;
        if (!IsPartial(syntax)) error = DiagnosticDescriptors.MustBePartial;
        if(IsNested(syntax)) error = DiagnosticDescriptors.NestedNotAllow;
        if (error is not null)
        {
            diagnostic = Diagnostic.Create(
                DiagnosticDescriptors.NestedNotAllow,
                syntax.Identifier.GetLocation(),
                symbol.Name
            );
            return false;
        }

        diagnostic = null;
        return true;
    }

    private static bool IsNested(SyntaxNode typeDeclaration) =>
        typeDeclaration.Parent is TypeDeclarationSyntax;

    private static bool IsPartial(MemberDeclarationSyntax syntax) =>
        syntax.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
}